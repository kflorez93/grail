#!/usr/bin/env node
import http from "node:http";
import fs from "node:fs";
import path from "node:path";
import os from "node:os";
const port = process.env.PORT ? Number(process.env.PORT) : 8787;
const schemaVersion = "0.1.0";
const maxParallel = Number(process.env.DOCUDEX_MAX_PARALLEL || 4);
const requestsPerSecond = Number(process.env.DOCUDEX_RPS || 4);
const cacheBaseEnv = process.env.DOCUDEX_CACHE_DIR || ".docudex-cache";
let activeRequests = 0;
const pendingQueue = [];
let lastRequestTimestamps = [];
function sleep(ms) {
 return new Promise(resolve => setTimeout(resolve, ms));
}
async function acquireSlot() {
 if (activeRequests pendingQueue.push(resolve));
 activeRequests += 1;
}
function releaseSlot() {
 activeRequests = Math.max(0, activeRequests - 1);
 const next = pendingQueue.shift();
 if (next) next();
}
async function rateLimit() {
 const now = Date.now();
 // purge timestamps older than 1s
 lastRequestTimestamps = lastRequestTimestamps.filter(t => now - t = requestsPerSecond) {
 const waitMs = 1000 - (now - lastRequestTimestamps[0]);
 if (waitMs > 0) await sleep(waitMs);
 }
 lastRequestTimestamps.push(Date.now());
}
function json(res, code, data) {
 res.writeHead(code, { "content-type": "application/json" });
 res.end(JSON.stringify(data));
}
function readBody(req) {
 return new Promise((resolve, reject) => {
 let data = "";
 req.on("data", chunk => { data += chunk; });
 req.on("end", () => resolve(data));
 req.on("error", reject);
 });
}
async function renderUrlWithPlaywright(pw, url, wait) {
 const browser = await pw.chromium.launch({ headless: true });
 const ctx = await browser.newContext();
 const page = await ctx.newPage();
 const waitStrategy = (wait && wait.strategy) || "networkidle";
 try {
 await page.goto(url, { waitUntil: ["networkidle", "load", "domcontentloaded"].includes(waitStrategy) ? "networkidle" : "load", timeout: 30000 });
 if (waitStrategy === "selector" && wait && wait.selector) {
 await page.waitForSelector(wait.selector, { timeout: 10000 });
 } else if (waitStrategy === "timeout" && wait && typeof wait.ms === "number") {
 await sleep(Math.max(0, wait.ms));
 }
 const title = await page.title();
 const html = await page.content();
 return { browser, ctx, page, title, html };
 } catch (err) {
 await ctx.close();
 await browser.close();
 throw err;
 }
}
function ensureAbsolute(p) {
 return path.isAbsolute(p) ? p : path.resolve(process.cwd(), p);
}
function ensureRunDir(baseDir) {
 const absBase = ensureAbsolute(baseDir);
 const stamp = Date.now().toString();
 const runDir = path.join(absBase, stamp);
 fs.mkdirSync(runDir, { recursive: true });
 return runDir;
}
async function handleRender(req, res) {
 try {
 const bodyRaw = await readBody(req);
 let payload = {};
 try { payload = bodyRaw ? JSON.parse(bodyRaw) : {}; } catch (_) {}
 const url = (payload.url || "").trim();
 const outDir = (payload.outDir || "").trim();
 const wait = payload.wait || undefined;
 if (!url) { return json(res, 400, { error: "url is required" }); }
 // Lazy import Playwright if available
 let pw;
 if (!process.env.DOCUDEX_DISABLE_BROWSER) {
 try {
 // eslint-disable-next-line import/no-extraneous-dependencies
 pw = await import("playwright");
 } catch (e) {
 // not installed; fall through to 501
 }
 }
 if (!pw) {
 return json(res, 501, { error: "playwright not installed", hint: "npm i -D playwright && npx playwright install", url });
 }
 await acquireSlot();
 await rateLimit();
 const { browser, ctx, page, title, html } = await renderUrlWithPlaywright(pw, url, wait);
 // Write artifacts
 const baseDir = outDir || cacheBaseEnv;
 const runDir = ensureRunDir(baseDir);
 const finalHtmlPath = path.join(runDir, "final.html");
 fs.writeFileSync(finalHtmlPath, html, "utf8");
 // optional screenshot
 let screenshotPath = "";
 try {
 screenshotPath = path.join(runDir, "page.png");
 await page.screenshot({ path: screenshotPath, fullPage: true });
 } catch (_) {
 screenshotPath = "";
 }
 await ctx.close();
 await browser.close();
 releaseSlot();
 return json(res, 200, {
 schema_version: schemaVersion,
 url,
 title,
 final_html: ensureAbsolute(finalHtmlPath),
 screenshot: screenshotPath ? ensureAbsolute(screenshotPath) : undefined,
 });
 } catch (err) {
 releaseSlot();
 return json(res, 500, { error: "render failed", message: String(err && err.message || err) });
 }
}
function extractPlainText(html) {
 try {
 // remove script/style
 const withoutScripts = html.replace(//gi, "").replace(//gi, "");
 // replace breaks/paragraphs with newlines
 const withNewlines = withoutScripts.replace(//gi, "\n");
 // strip tags
 const text = withNewlines.replace(/]+>/g, "");
 // collapse whitespace
 return text.replace(/\s+$/gm, "").replace(/[\t ]+/g, " ").replace(/\n{3,}/g, "\n\n").trim();
 } catch (_) {
 return "";
 }
}
function collectBasicMeta(html, url) {
 const titleMatch = html.match(/([\s\S]*?)/i);
 const title = titleMatch ? titleMatch[1].trim() : "";
 const headings = [];
 const headingRegex = /]*>([\s\S]*?)/gi;
 let m;
 while ((m = headingRegex.exec(html)) !== null) {
 const level = m[1];
 const text = m[2].replace(/]+>/g, "").trim();
 headings.push({ level, text });
 }
 const linkRegex = /]*href=["']([^"'#]+)["'][^>]*>([\s\S]*?)/gi;
 const links = [];
 while ((m = linkRegex.exec(html)) !== null) {
 const href = m[1];
 const text = m[2].replace(/]+>/g, "").trim();
 links.push({ href, text });
 }
 return { title, url, headings, links, collected_at: new Date().toISOString() };
}
async function handleExtract(req, res) {
 try {
 const bodyRaw = await readBody(req);
 let payload = {};
 try { payload = bodyRaw ? JSON.parse(bodyRaw) : {}; } catch (_) {}
 const url = (payload.url || "").trim();
 const htmlInput = typeof payload.html === "string" ? payload.html : "";
 const outDir = (payload.outDir || "").trim();
 const wait = payload.wait || undefined;
 if (!url && !htmlInput) { return json(res, 400, { error: "html or url is required" }); }
 let html = htmlInput;
 let effectiveUrl = url;
 // Lazy import Playwright if url provided
 if (!html && url && !process.env.DOCUDEX_DISABLE_BROWSER) {
 let pw;
 try { pw = await import("playwright"); } catch (e) {}
 if (!pw) { return json(res, 501, { error: "playwright not installed", hint: "npm i -D playwright && npx playwright install", url }); }
 await acquireSlot();
 await rateLimit();
 const { browser, ctx, page, html: pageHtml } = await renderUrlWithPlaywright(pw, url, wait);
 html = pageHtml;
 try { await ctx.close(); await browser.close(); } catch (_) {}
 releaseSlot();
 }
 if (!html) { return json(res, 400, { error: "failed to obtain html" }); }
 const baseDir = outDir || cacheBaseEnv;
 const runDir = ensureRunDir(baseDir);
 const readablePath = path.join(runDir, "readable.txt");
 const metaPath = path.join(runDir, "meta.json");
 const text = extractPlainText(html);
 const meta = collectBasicMeta(html, effectiveUrl || undefined);
 fs.writeFileSync(readablePath, text, "utf8");
 fs.writeFileSync(metaPath, JSON.stringify(meta, null, 2), "utf8");
 return json(res, 200, {
 schema_version: schemaVersion,
 readable_txt: ensureAbsolute(readablePath),
 meta_json: ensureAbsolute(metaPath)
 });
 } catch (err) {
 releaseSlot();
 return json(res, 500, { error: "extract failed", message: String(err && err.message || err) });
 }
}
const server = http.createServer(async (req, res) => {
 // Simple CORS for local tools
 res.setHeader("Access-Control-Allow-Origin", "*");
 res.setHeader("Access-Control-Allow-Methods", "GET,POST,OPTIONS");
 res.setHeader("Access-Control-Allow-Headers", "content-type");
 if (req.method === "OPTIONS") { res.writeHead(204); res.end(); return; }
 if (req.method === "GET" && req.url && (req.url === "/" || req.url.startsWith("/health"))) {
 const body = { status: "ok", port, browser: process.env.DOCUDEX_DISABLE_BROWSER ? "disabled" : "auto", schema_version: schemaVersion, limits: { maxParallel, rps: requestsPerSecond } };
 json(res, 200, body);
 return;
 }
 if (req.method === "POST" && req.url === "/render") {
 await handleRender(req, res);
 return;
 }
 if (req.method === "POST" && req.url === "/extract") {
 await handleExtract(req, res);
 return;
 }
 json(res, 404, { error: "not found" });
});
server.listen(port, "127.0.0.1", () => {
 console.log(`docudex daemon listening on http://127.0.0.1:${port}`);
});